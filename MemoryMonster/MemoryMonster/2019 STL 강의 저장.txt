============================
 Tue Mar 26 13:51:34 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include "MemoryMonster.h"
#include "save.h"

// 62p 1번문제
// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로 초기화한 후
// 반복자를 사용해 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라


int main()
{
	string s[5]{"3월", "22일", "MT", "베어스타운", "미세먼지없음"};

	auto b = begin(s);

	while (b != end(s))
	{
		cout << *b << endl;		
		++b;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 14:03:26 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include "MemoryMonster.h"
#include "save.h"

// 62p 1번문제
// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로 초기화한 후
// 반복자를 사용해 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라


int main()
{
	string s[5]{"C++","Standard","Template","Library","iostream"};

	// transform(어디부터, 어디까지, 어디로, 이렇게 바꿔서);
	transform(begin(s), end(s), ostream_iterator<string>(cout, "\n"),
	[](string& str) 
		{
			auto b = begin(str); 
			while (b != end(str))
			{
				// b가 모음이면 *로 바꿔라
				if (*b == 'a' || *b == 'e' || *b == 'i' || *b == 'o' || *b == 'u')
					*b = '*';
				b++;
			}
			return str;
		}
	);
	

	save("소스.cpp");
}

============================
 Tue Mar 26 14:05:32 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include "MemoryMonster.h"
#include "save.h"

// 62p 1번문제
// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로 초기화한 후
// 반복자를 사용해 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라


int main()
{
	string s[5]{"C++","Standard","Template","Library","iostream"};

	// transform(어디부터, 어디까지, 어디로, 이렇게 바꿔서);
	transform(begin(s), end(s), ostream_iterator<string>(cout, "\n"),
	[](string& str) 
		{
			auto b = begin(str); 
			while (b != end(str))
			{
				// b가 모음이면 *로 바꿔라
				if (*b == 'a' || *b == 'e' || *b == 'i' || *b == 'o' || *b == 'u')
					*b = '*';
				b++;
			}
			return str;
		}
	);

	cout << "원본 string" << endl;

	for (auto b : s)
	{
		cout << b << endl;
	}
	

	save("소스.cpp");
}

============================
 Tue Mar 26 14:11:27 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include "MemoryMonster.h"
#include "save.h"

// 62p 3번문제 - 대문자로 바꿔서 출력


int main()
{
	string s[5]{"C++","Standard","Template","Library","iostream"};

	// transform(어디부터, 어디까지, 어디로, 이렇게 바꿔서);
	transform(begin(s), end(s), ostream_iterator<string>(cout, "\n"),
		[](string& str) 
		{
			auto b = begin(str); 
			while (b != end(str))
			{
				*b = toupper(*b);
				b++;
			}
			return str;
		}
	);

	cout << "원본 string" << endl;

	for (auto b : s)
	{
		cout << b << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 14:59:06 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<int, 5> a{ 1,2,3,4,5 };

	for (int i = 0; i < 5; i++)
	{
		cout << a[i] << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:03:21 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<int, 5> a{ 1,2,3,4,5 };

	cout << "몇 번째 값을 원하니?";
	int num;
	cin >> num;

	try
	{
		cout << a.at(num) << endl;
	}
	catch (exception& e)
	{
		cout << e.what() << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:08:35 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<MemoryMonster, 5> a{10,3,30,7,20};

	for (auto p = begin(a); p != end(a); p++)
	{
		cout << *p << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:11:06 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<MemoryMonster, 5> a{10,3,30,7,20};

	for (int i = 0; i < a.size(); i++)
	{
		cout << a[i] << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:18:34 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<MemoryMonster, 5> a{10,3,30,7,20};

	// a의 각 원소를 오름차순으로 정렬하라

	for (int i = 0; i < a.size(); i++)
	{
		char* p = a[i].getP();
		sort(p, p + a[i].get());

		cout << a[i] << endl;
	}

	save("소스.cpp");
}


☆★☆★
//get -> getNum
//getP -> getData
//set -> reset 

============================
 Fri Mar 29 10:51:41 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너 (sequence container)
//   array
// - vector
//   deque
//   list
//   forward_list


int main()
{
	save("소스.cpp");
}

============================
 Fri Mar 29 11:08:21 2019
============================

#pragma once
//---------------------------------------------------------
// MemoryMonster.h
//
// 메모리를소모하는 MemotyMonster 클래스가 있다
// 정수를 인자로 받아 그 숫자만큼 세이브 한다.
//---------------------------------------------------------
#include <random>
using namespace std;



class MemoryMonster {
private:
	int num{ 0 };
	char *p{ nullptr };

public:
	int getNum() const; //확보한 메모리 갯수를 알려준다
	char* getData() const; // 확보한 메모리의 위치를 알린다

	void reset(int n); // 기존 메모리를 버리고 n개 만큼 새 메모리를 확보한다

	MemoryMonster() = default;

	MemoryMonster(int n);

	~MemoryMonster();

	MemoryMonster(const MemoryMonster& other);

	MemoryMonster& operator=(const MemoryMonster& other);

	MemoryMonster(MemoryMonster&&other);

	MemoryMonster& operator=(MemoryMonster&& other);

	friend ostream& operator<<(ostream&, const MemoryMonster&);
};

============================
 Fri Mar 29 11:08:21 2019
============================

#include "MemoryMonster.h"

default_random_engine dre;
uniform_int_distribution<>uid('a', 'z');

MemoryMonster::MemoryMonster(int n) : num{ n }
{
	p = new char[num];

	for (int i = 0; i < num; ++i)
		p[i] = uid(dre);
}

MemoryMonster::~MemoryMonster()
{
	//cout << "소멸자 - " << this << endl;
	if (p)
		delete[] p;
}

MemoryMonster& MemoryMonster::operator=(const MemoryMonster& other) {
	if (this == &other)
		return *this;

	delete[] p;
	p = new char[num];
	memcpy(p, other.p, num);
	return *this;
}

MemoryMonster::MemoryMonster(const MemoryMonster& other) : num(other.num)
{
	p = new char[num];
	memcpy(p, other.p, num);
}

MemoryMonster::MemoryMonster(MemoryMonster&&other) : num{ other.num }
{
	p = other.p;
	other.p = nullptr;
	other.num = 0;
}

void MemoryMonster::reset(int n) 
{
	// 이미 확보한 메모리는 해제한다
	if (p != nullptr)
		delete[] p;

	num = n;
	p = new char[num];

	for (int i = 0; i < num; ++i)
		p[i] = uid(dre);
}

int MemoryMonster::getNum() const 
{
	return num;
}

char* MemoryMonster::getData() const 
{
	return p;
}


MemoryMonster& MemoryMonster::operator=(MemoryMonster&& other) {
	delete[] p;
	num = other.num;
	p = other.p;
	other.p = nullptr;
	other.num = 0;

	return other;
}

ostream& operator<<(ostream& os, const MemoryMonster& mm)
{
	for (int i = 0; i < mm.num; ++i)
		os << mm.p[i];
	return os;
}

============================
 Fri Mar 29 11:08:21 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list


int main()
{
	save("MemoryMonster.h");
	save("MemoryMonster.cpp");
	save("소스.cpp");
}

============================
 Fri Mar 29 11:50:56 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list


int main()
{
	vector<MemoryMonster> v;

	cout << "현재 원소 갯수 - " << v.size() << endl;
	cout << "담을 수 있는 갯수 - " << v.capacity() << endl;
	cout << "확보한 메모리 위치(주소) - " << v.data() << endl;

	save("소스.cpp");
}

============================
 Fri Mar 29 12:09:52 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

uniform_int_distribution<> uid2(10, 70);
default_random_engine dre2;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// MemoryMonster 20개를 만들어 vector에 넣어라
// 초기값은 uid(10,70)로 만들어라
// vector를 .getNum() 오름차순으로 정렬하라
// 결과를 화면 출력한다

int main()
{
	//스스로 만들어봄
	vector<MemoryMonster> v;

	for(int i=0; i<20; i++)
	{
		v.push_back(uid2(dre2));

		char* p = v[i].getData();
		sort(p, p + v[i].getNum());

		cout << v[i] << endl;
	}
	save("소스.cpp");
}

============================
 Fri Mar 29 12:20:11 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

uniform_int_distribution<> uid2(10, 70);
default_random_engine dre2;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// MemoryMonster 20개를 만들어 vector에 넣어라
// 초기값은 uid(10,70)로 만들어라
// vector를 .getNum() 오름차순으로 정렬하라
// 결과를 화면 출력한다

int main()
{
	//교수님이 만듬
	vector<MemoryMonster> v;
	v.reserve(20); // 20개 예약함, <엄청 빨라져서 중요함!!!!☆★>

	for(int i=0; i<20; ++i)
		v.push_back(uid2(dre2));

	sort(v.begin(), v.end(), 
		[](const MemoryMonster& a, const MemoryMonster& b)
		{return a.getNum() < b.getNum(); }
	);

	for (const MemoryMonster& a : v)
		cout << a << endl;

	save("소스.cpp");
}

============================
 Tue Apr  2 14:15:02 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

uniform_int_distribution<> uid2(10, 70);
default_random_engine dre2;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// MemoryMonster 20개를 만들어 vector에 넣어라
// 초기값은 uid(10,70)로 만들어라
// vector를 .getNum() 오름차순으로 정렬하라
// 결과를 화면 출력한다

int main()
{
	vector<MemoryMonster> v;//v에 들어갈 애는 MemoryMonster.
	v.reserve(20);//20개 잡을거라고 예약. 이거 안하면 만들고 값 옮기고 번거로움. v야 너 20개를 담을 수 있는 애가 되었으면 좋겠어.
	// b 0
	// c 20
	// d MemoryMoster 20개 쭈루룩 있는 자리를 가리킴.

	default_random_engine dre;
	uniform_int_distribution<>uid(10, 70);

	cout << "push_back 하기 전" << endl;
	v.push_back(uid(dre));
	cout << "push_back 끝" << endl;


	//   for (int i = 0; i < 20; ++i) {
	//      v.push_back(uid(dre));
	//   }
	//
	//
	//   sort(v.begin(), v.end(), [](const MemoryMonster& a, const MemoryMonster& b) {return a.getNum() < b.getNum(); });
	//
	//   /*for (auto i = v.begin(); i != v.end(); ++i) {
	//      cout << *i << endl;
	//   }
	//*/
	//   for (const MemoryMonster& a : v)
	//      cout << a << endl;

	save("소스.cpp");

	cout << "main 끝나기 전" << endl;
}

============================
 Tue Apr  2 14:39:46 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	//v.reserve(20);

	v.push_back(10);
	v.push_back(20);

	
	save("소스.cpp");
}

============================
 Tue Apr  2 14:42:53 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(2);

	v.push_back(10);
	v.push_back(20);

	
	save("소스.cpp");
}

============================
 Tue Apr  2 14:44:22 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(2);

	v.emplace_back(10);
	v.emplace_back(20);

	
	save("소스.cpp");
}

============================
 Tue Apr  2 15:08:15 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// 입력자료구조 - 키보드
// 출력자료구조 - 화면

// 키보드에서 string를 읽어 오름차순으로 정렬함여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>() };

	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	
	save("소스.cpp");
}

============================
 Tue Apr  2 15:16:22 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// 입력자료구조 - 키보드
// 출력자료구조 - 화면

// 키보드에서 string를 읽어 오름차순으로 정렬함여 출력하라.
// 소스.cpp에서 char을 읽어 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in("소스.cpp");

	vector<char> v{ istream_iterator<char>(in), istream_iterator<char>() };

	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<char>(cout));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	
	save("소스.cpp");
}

============================
 Fri Apr  5 10:47:38 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(30);

	cout << "중간에 20을 넣기 전" << endl;
	// 10과 30사이에 20을 끼워넣어 보자
	v.emplace(v.begin() + 1, 20);

	cout << "중간에 20을 넣기 후" << endl;
	
	save("소스.cpp");
}

============================
 Fri Apr  5 11:26:45 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);
	v.emplace_back(40);

	cout << "중간에 20을 삭제하기 전" << endl;

	// 20글자를 갖는 객체를 삭제하자 / p95 참조
	v.erase(remove(v.begin(), v.end(), 20), v.end());

	cout << "중간에 20을 삭제한 후" << endl;
	
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	save("소스.cpp");
}

============================
 Fri Apr  5 11:28:30 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(10); // <- 이거안쓰면 복사되고 소멸되고 난리도아님 vector한정

	v.emplace_back(10);
	v.emplace_back(30);
	v.emplace_back(40);
	v.emplace_back(50);

	cout << "중간에 20을 삽입" << endl;
	v.emplace(v.begin() + 1, 20);

	cout << "중간에 20을 insert 한 후" << endl;
	
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	save("소스.cpp");
}

============================
 Fri Apr  5 12:03:18 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>
#include <fstream>

using namespace std;

// 입력 : 소스.cpp
// 출력 : e없는소스.cpp
// 변신 : 소스.cpp에서 영문자 e를 제거한다
//		  remove_if()를 사용한다
// 공백(white space)까지 처라하려면 istreambuf_iterator, ostreambuf_iterator 사용
int main()
{
	ifstream in("소스.cpp");
	
	vector<char> v{istreambuf_iterator<char>(in), istreambuf_iterator<char>()};
	auto p = remove_if(v.begin(), v.end(), [](const char c) 
	{
		if (c == 'e')
			return true;
		return false;
	});

	v.erase(p, v.end());
	
	ofstream out("e없는소스.cpp");
	copy(v.begin(), v.end(), ostreambuf_iterator<char>(out));

	in.close();

	save("소스.cpp");
}

============================
 Tue Apr  9 13:41:34 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// deque에 MemoryMonster {10, 20, 30)을 추가해보자
// deque의 원소를 화면에 출력해보자

int main()
{
	deque<MemoryMonster> d{10, 20, 30};
	// 초기화 했을때 deque의 복사생성자 주소는 붙어있지 않다

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
		// 벡터 d[0] + i
		// 덱 d[0]->(100)d[i]---->>dkkkdkd
	}

	save("소스.cpp");
}

============================
 Tue Apr  9 13:56:07 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// deque에 MemoryMonster {10, 20, 30)을 추가해보자
// deque의 원소를 화면에 출력해보자

int main()
{
	deque<MemoryMonster> d;

	// 10, 20, 30 추가
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
	}

	save("소스.cpp");
}

============================
 Tue Apr  9 14:12:50 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
#include <fstream>
#include <iterator>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// 소스.cpp를 
// deque에 저장하자
// 뒤에서부터 화면 출력하라

int main()
{
	ifstream in("소스.cpp");
	deque<char> d{ istreambuf_iterator<char>(in), istreambuf_iterator<char>() };

	for (auto i = d.rbegin(); i < d.rend(); ++i)
		cout << *i;

	save("소스.cpp");
}

============================
 Tue Apr  9 14:15:28 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
#include <fstream>
#include <iterator>
#include <algorithm>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// 소스.cpp를 
// deque에 저장하자
// 뒤에서부터 화면 출력하라

int main()
{
	ifstream in("소스.cpp");
	deque<char> d{ istreambuf_iterator<char>(in), istreambuf_iterator<char>() };

	// 이거 더잘 출력됨
	copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	cout << endl;

	save("소스.cpp");
}

============================
 Tue Apr  9 14:50:33 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
#include <fstream>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<string> s;
	vector<char> c;

	string str;
	cin >> str;
	s.push_back(str);

	for (char d : s[0])
		c.push_back(d);

	for (int i = 0; i < c.size(); ++i)
		cout << c[i] << ' ';

	save("소스.cpp");
}

============================
 Tue Apr  9 15:13:02 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque
// - list
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters;
	auto p = monsters.begin();

	p = monsters.emplace(p, 10);
	p = monsters.emplace(p, 20);
	p = monsters.emplace(p, 30);

	for (auto i = monsters.begin(); i != monsters.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

============================
 Tue Apr  9 15:15:12 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque
// - list
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters;
	auto p = monsters.begin();

	p = monsters.emplace(p, 10);
	p = monsters.emplace(p, 20);
	p = monsters.emplace(p, 30);

	for (MemoryMonster& mon : monsters)
		cout << mon << endl;

	save("소스.cpp");
}
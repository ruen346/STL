============================
 Tue Mar 26 13:51:34 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include "MemoryMonster.h"
#include "save.h"

// 62p 1번문제
// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로 초기화한 후
// 반복자를 사용해 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라


int main()
{
	string s[5]{"3월", "22일", "MT", "베어스타운", "미세먼지없음"};

	auto b = begin(s);

	while (b != end(s))
	{
		cout << *b << endl;		
		++b;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 14:03:26 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include "MemoryMonster.h"
#include "save.h"

// 62p 1번문제
// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로 초기화한 후
// 반복자를 사용해 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라


int main()
{
	string s[5]{"C++","Standard","Template","Library","iostream"};

	// transform(어디부터, 어디까지, 어디로, 이렇게 바꿔서);
	transform(begin(s), end(s), ostream_iterator<string>(cout, "\n"),
	[](string& str) 
		{
			auto b = begin(str); 
			while (b != end(str))
			{
				// b가 모음이면 *로 바꿔라
				if (*b == 'a' || *b == 'e' || *b == 'i' || *b == 'o' || *b == 'u')
					*b = '*';
				b++;
			}
			return str;
		}
	);
	

	save("소스.cpp");
}

============================
 Tue Mar 26 14:05:32 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include "MemoryMonster.h"
#include "save.h"

// 62p 1번문제
// std::string 객체로 된 배열을 정의하고, 자신이 선택한 단어들로 초기화한 후
// 반복자를 사용해 배열의 내용을 한 줄에 하나씩 출력하는 프로그램을 작성하라


int main()
{
	string s[5]{"C++","Standard","Template","Library","iostream"};

	// transform(어디부터, 어디까지, 어디로, 이렇게 바꿔서);
	transform(begin(s), end(s), ostream_iterator<string>(cout, "\n"),
	[](string& str) 
		{
			auto b = begin(str); 
			while (b != end(str))
			{
				// b가 모음이면 *로 바꿔라
				if (*b == 'a' || *b == 'e' || *b == 'i' || *b == 'o' || *b == 'u')
					*b = '*';
				b++;
			}
			return str;
		}
	);

	cout << "원본 string" << endl;

	for (auto b : s)
	{
		cout << b << endl;
	}
	

	save("소스.cpp");
}

============================
 Tue Mar 26 14:11:27 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
#include "MemoryMonster.h"
#include "save.h"

// 62p 3번문제 - 대문자로 바꿔서 출력


int main()
{
	string s[5]{"C++","Standard","Template","Library","iostream"};

	// transform(어디부터, 어디까지, 어디로, 이렇게 바꿔서);
	transform(begin(s), end(s), ostream_iterator<string>(cout, "\n"),
		[](string& str) 
		{
			auto b = begin(str); 
			while (b != end(str))
			{
				*b = toupper(*b);
				b++;
			}
			return str;
		}
	);

	cout << "원본 string" << endl;

	for (auto b : s)
	{
		cout << b << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 14:59:06 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<int, 5> a{ 1,2,3,4,5 };

	for (int i = 0; i < 5; i++)
	{
		cout << a[i] << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:03:21 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<int, 5> a{ 1,2,3,4,5 };

	cout << "몇 번째 값을 원하니?";
	int num;
	cin >> num;

	try
	{
		cout << a.at(num) << endl;
	}
	catch (exception& e)
	{
		cout << e.what() << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:08:35 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<MemoryMonster, 5> a{10,3,30,7,20};

	for (auto p = begin(a); p != end(a); p++)
	{
		cout << *p << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:11:06 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<MemoryMonster, 5> a{10,3,30,7,20};

	for (int i = 0; i < a.size(); i++)
	{
		cout << a[i] << endl;
	}

	save("소스.cpp");
}

============================
 Tue Mar 26 15:18:34 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너
// - array
// - vector
// - deque
// - list
// - forward_list


int main()
{
	array<MemoryMonster, 5> a{10,3,30,7,20};

	// a의 각 원소를 오름차순으로 정렬하라

	for (int i = 0; i < a.size(); i++)
	{
		char* p = a[i].getP();
		sort(p, p + a[i].get());

		cout << a[i] << endl;
	}

	save("소스.cpp");
}


☆★☆★
//get -> getNum
//getP -> getData
//set -> reset 

============================
 Fri Mar 29 10:51:41 2019
============================

#include <iostream>
#include <string>
#include <algorithm>
#include <iterator>
// #include <initializer_list>
#include <array>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너 (sequence container)
//   array
// - vector
//   deque
//   list
//   forward_list


int main()
{
	save("소스.cpp");
}

============================
 Fri Mar 29 11:08:21 2019
============================

#pragma once
//---------------------------------------------------------
// MemoryMonster.h
//
// 메모리를소모하는 MemotyMonster 클래스가 있다
// 정수를 인자로 받아 그 숫자만큼 세이브 한다.
//---------------------------------------------------------
#include <random>
using namespace std;



class MemoryMonster {
private:
	int num{ 0 };
	char *p{ nullptr };

public:
	int getNum() const; //확보한 메모리 갯수를 알려준다
	char* getData() const; // 확보한 메모리의 위치를 알린다

	void reset(int n); // 기존 메모리를 버리고 n개 만큼 새 메모리를 확보한다

	MemoryMonster() = default;

	MemoryMonster(int n);

	~MemoryMonster();

	MemoryMonster(const MemoryMonster& other);

	MemoryMonster& operator=(const MemoryMonster& other);

	MemoryMonster(MemoryMonster&&other);

	MemoryMonster& operator=(MemoryMonster&& other);

	friend ostream& operator<<(ostream&, const MemoryMonster&);
};

============================
 Fri Mar 29 11:08:21 2019
============================

#include "MemoryMonster.h"

default_random_engine dre;
uniform_int_distribution<>uid('a', 'z');

MemoryMonster::MemoryMonster(int n) : num{ n }
{
	p = new char[num];

	for (int i = 0; i < num; ++i)
		p[i] = uid(dre);
}

MemoryMonster::~MemoryMonster()
{
	//cout << "소멸자 - " << this << endl;
	if (p)
		delete[] p;
}

MemoryMonster& MemoryMonster::operator=(const MemoryMonster& other) {
	if (this == &other)
		return *this;

	delete[] p;
	p = new char[num];
	memcpy(p, other.p, num);
	return *this;
}

MemoryMonster::MemoryMonster(const MemoryMonster& other) : num(other.num)
{
	p = new char[num];
	memcpy(p, other.p, num);
}

MemoryMonster::MemoryMonster(MemoryMonster&&other) : num{ other.num }
{
	p = other.p;
	other.p = nullptr;
	other.num = 0;
}

void MemoryMonster::reset(int n) 
{
	// 이미 확보한 메모리는 해제한다
	if (p != nullptr)
		delete[] p;

	num = n;
	p = new char[num];

	for (int i = 0; i < num; ++i)
		p[i] = uid(dre);
}

int MemoryMonster::getNum() const 
{
	return num;
}

char* MemoryMonster::getData() const 
{
	return p;
}


MemoryMonster& MemoryMonster::operator=(MemoryMonster&& other) {
	delete[] p;
	num = other.num;
	p = other.p;
	other.p = nullptr;
	other.num = 0;

	return other;
}

ostream& operator<<(ostream& os, const MemoryMonster& mm)
{
	for (int i = 0; i < mm.num; ++i)
		os << mm.p[i];
	return os;
}

============================
 Fri Mar 29 11:08:21 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list


int main()
{
	save("MemoryMonster.h");
	save("MemoryMonster.cpp");
	save("소스.cpp");
}

============================
 Fri Mar 29 11:50:56 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list


int main()
{
	vector<MemoryMonster> v;

	cout << "현재 원소 갯수 - " << v.size() << endl;
	cout << "담을 수 있는 갯수 - " << v.capacity() << endl;
	cout << "확보한 메모리 위치(주소) - " << v.data() << endl;

	save("소스.cpp");
}

============================
 Fri Mar 29 12:09:52 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

uniform_int_distribution<> uid2(10, 70);
default_random_engine dre2;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// MemoryMonster 20개를 만들어 vector에 넣어라
// 초기값은 uid(10,70)로 만들어라
// vector를 .getNum() 오름차순으로 정렬하라
// 결과를 화면 출력한다

int main()
{
	//스스로 만들어봄
	vector<MemoryMonster> v;

	for(int i=0; i<20; i++)
	{
		v.push_back(uid2(dre2));

		char* p = v[i].getData();
		sort(p, p + v[i].getNum());

		cout << v[i] << endl;
	}
	save("소스.cpp");
}

============================
 Fri Mar 29 12:20:11 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

uniform_int_distribution<> uid2(10, 70);
default_random_engine dre2;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// MemoryMonster 20개를 만들어 vector에 넣어라
// 초기값은 uid(10,70)로 만들어라
// vector를 .getNum() 오름차순으로 정렬하라
// 결과를 화면 출력한다

int main()
{
	//교수님이 만듬
	vector<MemoryMonster> v;
	v.reserve(20); // 20개 예약함, <엄청 빨라져서 중요함!!!!☆★>

	for(int i=0; i<20; ++i)
		v.push_back(uid2(dre2));

	sort(v.begin(), v.end(), 
		[](const MemoryMonster& a, const MemoryMonster& b)
		{return a.getNum() < b.getNum(); }
	);

	for (const MemoryMonster& a : v)
		cout << a << endl;

	save("소스.cpp");
}

============================
 Tue Apr  2 14:15:02 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

uniform_int_distribution<> uid2(10, 70);
default_random_engine dre2;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// MemoryMonster 20개를 만들어 vector에 넣어라
// 초기값은 uid(10,70)로 만들어라
// vector를 .getNum() 오름차순으로 정렬하라
// 결과를 화면 출력한다

int main()
{
	vector<MemoryMonster> v;//v에 들어갈 애는 MemoryMonster.
	v.reserve(20);//20개 잡을거라고 예약. 이거 안하면 만들고 값 옮기고 번거로움. v야 너 20개를 담을 수 있는 애가 되었으면 좋겠어.
	// b 0
	// c 20
	// d MemoryMoster 20개 쭈루룩 있는 자리를 가리킴.

	default_random_engine dre;
	uniform_int_distribution<>uid(10, 70);

	cout << "push_back 하기 전" << endl;
	v.push_back(uid(dre));
	cout << "push_back 끝" << endl;


	//   for (int i = 0; i < 20; ++i) {
	//      v.push_back(uid(dre));
	//   }
	//
	//
	//   sort(v.begin(), v.end(), [](const MemoryMonster& a, const MemoryMonster& b) {return a.getNum() < b.getNum(); });
	//
	//   /*for (auto i = v.begin(); i != v.end(); ++i) {
	//      cout << *i << endl;
	//   }
	//*/
	//   for (const MemoryMonster& a : v)
	//      cout << a << endl;

	save("소스.cpp");

	cout << "main 끝나기 전" << endl;
}

============================
 Tue Apr  2 14:39:46 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	//v.reserve(20);

	v.push_back(10);
	v.push_back(20);

	
	save("소스.cpp");
}

============================
 Tue Apr  2 14:42:53 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(2);

	v.push_back(10);
	v.push_back(20);

	
	save("소스.cpp");
}

============================
 Tue Apr  2 14:44:22 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(2);

	v.emplace_back(10);
	v.emplace_back(20);

	
	save("소스.cpp");
}

============================
 Tue Apr  2 15:08:15 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// 입력자료구조 - 키보드
// 출력자료구조 - 화면

// 키보드에서 string를 읽어 오름차순으로 정렬함여 출력하라.

int main()
{
	vector<string> v{ istream_iterator<string>(cin), istream_iterator<string>() };

	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\t"));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	
	save("소스.cpp");
}

============================
 Tue Apr  2 15:16:22 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

// 입력자료구조 - 키보드
// 출력자료구조 - 화면

// 키보드에서 string를 읽어 오름차순으로 정렬함여 출력하라.
// 소스.cpp에서 char을 읽어 오름차순으로 정렬하여 출력하라.

int main()
{
	ifstream in("소스.cpp");

	vector<char> v{ istream_iterator<char>(in), istream_iterator<char>() };

	sort(v.begin(), v.end());
	copy(v.begin(), v.end(), ostream_iterator<char>(cout));

	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	
	save("소스.cpp");
}

============================
 Fri Apr  5 10:47:38 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(30);

	cout << "중간에 20을 넣기 전" << endl;
	// 10과 30사이에 20을 끼워넣어 보자
	v.emplace(v.begin() + 1, 20);

	cout << "중간에 20을 넣기 후" << endl;
	
	save("소스.cpp");
}

============================
 Fri Apr  5 11:26:45 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(10);

	v.emplace_back(10);
	v.emplace_back(20);
	v.emplace_back(30);
	v.emplace_back(40);

	cout << "중간에 20을 삭제하기 전" << endl;

	// 20글자를 갖는 객체를 삭제하자 / p95 참조
	v.erase(remove(v.begin(), v.end(), 20), v.end());

	cout << "중간에 20을 삭제한 후" << endl;
	
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	save("소스.cpp");
}

============================
 Fri Apr  5 11:28:30 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>

using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
// - vector
//   deque
//   list
//   forward_list

int main()
{
	vector<MemoryMonster> v;
	v.reserve(10); // <- 이거안쓰면 복사되고 소멸되고 난리도아님 vector한정

	v.emplace_back(10);
	v.emplace_back(30);
	v.emplace_back(40);
	v.emplace_back(50);

	cout << "중간에 20을 삽입" << endl;
	v.emplace(v.begin() + 1, 20);

	cout << "중간에 20을 insert 한 후" << endl;
	
	for (int i = 0; i < v.size(); ++i)
		cout << v[i] << endl;

	save("소스.cpp");
}

============================
 Fri Apr  5 12:03:18 2019
============================

#include <iostream>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

#include <iterator>
#include <string>
#include <algorithm>
#include <fstream>

using namespace std;

// 입력 : 소스.cpp
// 출력 : e없는소스.cpp
// 변신 : 소스.cpp에서 영문자 e를 제거한다
//		  remove_if()를 사용한다
// 공백(white space)까지 처라하려면 istreambuf_iterator, ostreambuf_iterator 사용
int main()
{
	ifstream in("소스.cpp");
	
	vector<char> v{istreambuf_iterator<char>(in), istreambuf_iterator<char>()};
	auto p = remove_if(v.begin(), v.end(), [](const char c) 
	{
		if (c == 'e')
			return true;
		return false;
	});

	v.erase(p, v.end());
	
	ofstream out("e없는소스.cpp");
	copy(v.begin(), v.end(), ostreambuf_iterator<char>(out));

	in.close();

	save("소스.cpp");
}

============================
 Tue Apr  9 13:41:34 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// deque에 MemoryMonster {10, 20, 30)을 추가해보자
// deque의 원소를 화면에 출력해보자

int main()
{
	deque<MemoryMonster> d{10, 20, 30};
	// 초기화 했을때 deque의 복사생성자 주소는 붙어있지 않다

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
		// 벡터 d[0] + i
		// 덱 d[0]->(100)d[i]---->>dkkkdkd
	}

	save("소스.cpp");
}

============================
 Tue Apr  9 13:56:07 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// deque에 MemoryMonster {10, 20, 30)을 추가해보자
// deque의 원소를 화면에 출력해보자

int main()
{
	deque<MemoryMonster> d;

	// 10, 20, 30 추가
	d.emplace_back(10);
	d.emplace_back(20);
	d.emplace_back(30);

	for (int i = 0; i < d.size(); ++i)
	{
		cout << d[i] << endl;
	}

	save("소스.cpp");
}

============================
 Tue Apr  9 14:12:50 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
#include <fstream>
#include <iterator>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// 소스.cpp를 
// deque에 저장하자
// 뒤에서부터 화면 출력하라

int main()
{
	ifstream in("소스.cpp");
	deque<char> d{ istreambuf_iterator<char>(in), istreambuf_iterator<char>() };

	for (auto i = d.rbegin(); i < d.rend(); ++i)
		cout << *i;

	save("소스.cpp");
}

============================
 Tue Apr  9 14:15:28 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
#include <fstream>
#include <iterator>
#include <algorithm>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
// - deque
//   list
//   forward_list

// 소스.cpp를 
// deque에 저장하자
// 뒤에서부터 화면 출력하라

int main()
{
	ifstream in("소스.cpp");
	deque<char> d{ istreambuf_iterator<char>(in), istreambuf_iterator<char>() };

	// 이거 더잘 출력됨
	copy(d.rbegin(), d.rend(), ostreambuf_iterator<char>(cout));
	cout << endl;

	save("소스.cpp");
}

============================
 Tue Apr  9 14:50:33 2019
============================

#include <iostream>
#include <deque>
#include "MemoryMonster.h"
#include "save.h"
#include <fstream>
#include <iterator>
#include <algorithm>
using namespace std;

int main()
{
	vector<string> s;
	vector<char> c;

	string str;
	cin >> str;
	s.push_back(str);

	for (char d : s[0])
		c.push_back(d);

	for (int i = 0; i < c.size(); ++i)
		cout << c[i] << ' ';

	save("소스.cpp");
}

============================
 Tue Apr  9 15:13:02 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque
// - list
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters;
	auto p = monsters.begin();

	p = monsters.emplace(p, 10);
	p = monsters.emplace(p, 20);
	p = monsters.emplace(p, 30);

	for (auto i = monsters.begin(); i != monsters.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

============================
 Tue Apr  9 15:15:12 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque
// - list
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters;
	auto p = monsters.begin();

	p = monsters.emplace(p, 10);
	p = monsters.emplace(p, 20);
	p = monsters.emplace(p, 30);

	for (MemoryMonster& mon : monsters)
		cout << mon << endl;

	save("소스.cpp");
}

============================
 Fri Apr 12 10:38:12 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters{ 10, 20, 30, 3, 40, 50 };

	// 리스트에서 길이가 10보다 작은 원소를 제거하라.
	remove_if(monsters.begin(), monsters.end(), 
	[](const MemoryMonster& a)
	{
		return a.getNum() < 10;
	}
	);

	for (MemoryMonster& mon : monsters)
		cout << mon << endl;

	save("소스.cpp");
}

============================
 Fri Apr 12 10:41:06 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters{ 10, 20, 30, 3, 40, 50 };

	// 리스트에서 길이가 10보다 작은 원소를 제거하라.
	auto p = remove_if(monsters.begin(), monsters.end(), 
	[](const MemoryMonster& a)
	{
		return a.getNum() < 10;
	});
	monsters.erase(p, monsters.end());

	cout << "----------------------" << endl;
	for (MemoryMonster& mon : monsters)
		cout << mon << endl;

	save("소스.cpp");
}

============================
 Fri Apr 12 10:52:28 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// list에 MemoryMonster 3개를 추가해보세요
// 각 원소를 출력해보세요

int main()
{
	list<MemoryMonster> monsters{ 10, 20, 30, 3, 40, 50 };

	// 리스트에서 길이가 10보다 작은 원소를 제거하라.
	monsters.remove_if([](const MemoryMonster& a) {
		return a.getNum() < 10;
	});

	cout << "-------------------------" << endl;
	for (MemoryMonster& mon : monsters)
		cout << mon << endl;
	cout << "-------------------------" << endl;

	save("소스.cpp");
}

============================
 Fri Apr 12 11:21:29 2019
============================

#include <iostream>
#include <list>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

int main()
{
	list<MemoryMonster> monsters1{ 9, 3, 1, 7, 5 };
	list<MemoryMonster> monsters2{ 6, 2, 8, 4, 10 };

	// merge는 정렬된 list일때 의미있는 동작이다
	monsters1.sort([](const MemoryMonster& a, MemoryMonster& b) {return a.getNum() < b.getNum(); });
	monsters2.sort([](const MemoryMonster& a, MemoryMonster& b) {return a.getNum() < b.getNum(); });

	// monsters1과 2를 merge해서 그 결과는 monsters1에 저장하라
	monsters1.merge(monsters2);

	cout << "-------------------------" << endl;
	for (MemoryMonster& mon : monsters1)
		cout << mon << endl;
	cout << "-------------------------" << endl;

	cout << "-------------------------" << endl;
	for (MemoryMonster& mon : monsters2)
		cout << mon << endl;
	cout << "-------------------------" << endl;

	save("소스.cpp");
}

============================
 Tue Apr 16 13:49:13 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

void print(list<MemoryMonster>::iterator, list<MemoryMonster>::iterator);

int main()
{
	list<MemoryMonster> monsters{ 10, 20, 30 };
	
	print(monsters.begin(), monsters.end()); // 화면에 원소를 출력한다
	
	save("소스.cpp");
}

void print(list<MemoryMonster>::iterator a, list<MemoryMonster>::iterator b)
{

	while (a != b)
		cout << *a++ << endl;
}

============================
 Tue Apr 16 13:55:54 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <vector>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

void print(list<MemoryMonster>::iterator, list<MemoryMonster>::iterator);
void print(vector<MemoryMonster>::iterator, vector<MemoryMonster>::iterator);

int main()
{
	vector<MemoryMonster> monsters{ 10, 20, 30 };
	
	print(monsters.begin(), monsters.end()); // 화면에 원소를 출력한다
	
	save("소스.cpp");
}

void print(list<MemoryMonster>::iterator a, list<MemoryMonster>::iterator b)
{

	while (a != b)
		cout << *a++ << endl;
}

void print(vector<MemoryMonster>::iterator a, vector<MemoryMonster>::iterator b)
{

	while (a != b)
		cout << *a++ << endl;
}

============================
 Tue Apr 16 14:02:58 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <vector>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template <class Iter>
void print(Iter b, Iter e);

int main()
{
	list<MemoryMonster> monsters{ 10, 20, 30 };
	
	print(monsters.begin(), monsters.end()); // 화면에 원소를 출력한다
	
	save("소스.cpp");
}

template <class Iter>
void print(Iter beg, Iter end)
{
	while (beg != end)
		cout << *beg++ << endl;
}

============================
 Tue Apr 16 14:12:08 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <vector>
#include <string>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template <class Iter>
void print(Iter b, Iter e);

template <class T>
T Add(T a, T b);

int main()
{
	list<MemoryMonster> monsters{ 10, 20, 30 };
	
	print(monsters.begin(), monsters.end()); // 화면에 원소를 출력한다

	cout << Add(1, 2) << endl;
	cout << Add<string>("Hello", " World") << endl;
	
	save("소스.cpp");
}

template <class Iter>
void print(Iter beg, Iter end)
{
	while (beg != end)
		cout << *beg++ << endl;
}

template <class T>
T Add(T a, T b)
{
	// Type_trait를 이용하면 전달된 T에 대한 추가정보를 알 수 있다
	// cout << is_abstract<T>() << endl;
	// cout << is_arithmetic<T>() << endl;

	return a + b;
}

============================
 Tue Apr 16 14:20:38 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <algorithm>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자
template <class Iter>
void x(Iter b, Iter e);

int main()
{
	list<MemoryMonster> monsters{ 3, 1, 7, 9, 5 };
	
	x(monsters.begin(), monsters.end());

	save("소스.cpp");
}

template <class Iter>
void x(Iter b, Iter e)
{
	cout << typeid(iterator_traits<Iter>::iterator_category()).name() << endl;
}

============================
 Tue Apr 16 14:37:06 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <algorithm>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
// - list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template <class Iter>
void f(Iter i);

int main()
{
	vector<int> v;

	f(v.begin()); // 랜덤억세스

	list<int> l;
	f(l.begin()); // 양방향반복자

	save("소스.cpp");
}

template <class Iter>
void f(Iter i)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}

============================
 Tue Apr 16 14:39:52 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <algorithm>
#include <forward_list>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
//   list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template <class Iter>
void f(Iter i);

int main()
{
	vector<int> v;
	f(v.begin()); // 랜덤억세스

	list<int> l;
	f(l.begin()); // 양방향반복자

	forward_list<int> fl;
	f(fl.begin()); // 전진반복자

	ostream_iterator<int> oi(cout);
	f(oi); // 출력반복자

	f(istream_iterator<int>()); // 입력반복자

	// STL의 5개 반복자

	save("소스.cpp");
}

template <class Iter>
void f(Iter i)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}

============================
 Tue Apr 16 14:46:37 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
#include <algorithm>
#include <forward_list>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
//   list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template <class Iter>
void f(Iter i);

class MyIter : public iterator<input_iterator_tag, int, int*> // 사용자정의 반복자
{

};

int main()
{
	vector<int> v;
	f(v.begin()); // 랜덤억세스

	list<int> l;
	f(l.begin()); // 양방향반복자

	forward_list<int> fl;
	f(fl.begin()); // 전진반복자

	ostream_iterator<int> oi(cout);
	f(oi); // 출력반복자

	f(istream_iterator<int>()); // 입력반복자

	// STL의 5개 반복자


	f(MyIter());

	save("소스.cpp");
}

template <class Iter>
void f(Iter i)
{
	cout << typeid(iterator_traits<Iter>::iterator_category).name() << endl;
}

============================
 Tue Apr 16 14:49:22 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
//   list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	list<int> l;

	copy(v.begin(), v.end(), ostream_iterator<int>(cout, "\n"));

	save("소스.cpp");
}

============================
 Tue Apr 16 14:59:17 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <list>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
//   list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template<class Src, class Des>
void myCopy(Src b, Src e, Des d);

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	list<int> l;

	myCopy(v.begin(), v.end(), ostream_iterator<int>(cout, "\n"));

	save("소스.cpp");
}

template<class Src, class Des>
void myCopy(Src b, Src e, Des d)
{
	while (b != e)
		*d++ = *b++;
}

============================
 Tue Apr 16 15:13:45 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <vector>
#include <list>
using namespace std;

// 2장 순차 컨테이너 (sequence container, (homogeneous data type만 담는다))
//   array : smart 배열, []를 완벽하게 대체한다
//   vector : dynamic array (STL 간판선수)
//   deque : double-ended queue, 덱
//   list : 이후 컨테이너는 원소보다 더 큰 메모리를 사용한다
//   forward_list

// copy의 정체를 밝혀보자

template<class Src, class Des>
void myCopy(Src b, Src e, Des d);

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	vector<int> w;

	myCopy(v.begin(), v.end(), back_inserter(w));

	save("소스.cpp");
}

template<class Src, class Des>
void myCopy(Src b, Src e, Des d)
{
	while (b != e)
		*d++ = *b++;
}

============================
 Fri Apr 19 11:14:07 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <map>
#include <string>
using namespace std;

// Associative Container (연관 컨테이너)
//	map - dirctionay <key, value> 쌍이 원소
//	set - <key>가 원소
//
// Unordered Associative Contaiiner (순서없는 연관 컨테이너, Hash)
//	Unordered_map
//	Unordered_set

// 아이돌그룹의 이름과 멤버 수 

int main()
{
	// pair 설명
	pair<string, int> p{ "c++",17 };
	cout << p.first << ", " << p.second << endl;


	map<string, int> idols;

	idols.insert(pair<string, int>("핑크레이디", 5)); // 2개를 하나처럼 페어 
	idols.insert(make_pair("있지", 5)); // 위에꺼 쉽게 쓰기
	idols.insert(make_pair("아이즈원", 12));
	idols.insert(make_pair("워너원", 11));
	idols.insert(make_pair("모모랜드", 9));
	idols.insert(make_pair("블랙핑크", 4));
	idols.insert(make_pair("트와이스", 9));
	idols.insert(make_pair("세븐틴", 13));
	idols.insert(make_pair("방탄소년단", 7));

	save("소스.cpp");
}

============================
 Fri Apr 19 11:19:49 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <map>
#include <string>
using namespace std;

// Associative Container (연관 컨테이너)
//	map - dirctionay <key, value> 쌍이 원소
//	set - <key>가 원소
//
// Unordered Associative Contaiiner (순서없는 연관 컨테이너, Hash)
//	Unordered_map
//	Unordered_set

// 아이돌그룹의 이름과 멤버 수 
// map에 입력하고 출력해 보자

int main()
{
	map<string, int> idols;

	idols.insert(pair<string, int>("핑크레이디", 5)); // 2개를 하나처럼 페어 
	idols.insert(make_pair("있지", 5)); // 위에꺼 쉽게 쓰기
	idols.insert(make_pair("아이즈원", 12));
	idols.insert(make_pair("워너원", 11));
	idols.insert(make_pair("모모랜드", 9));
	idols.insert(make_pair("블랙핑크", 4));
	idols.insert(make_pair("트와이스", 9));
	idols.insert(make_pair("세븐틴", 13));
	idols.insert(make_pair("방탄소년단", 7));

	for (auto i = idols.begin(); i != idols.end(); ++i)
	{
		cout << i->first << ", " << i->second << endl;
	}

	save("소스.cpp");
}

============================
 Fri Apr 19 11:46:45 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <map>
#include <string>
using namespace std;

// Associative Container (연관 컨테이너)
//	map - dirctionay <key, value> 쌍이 원소
//	set - <key>가 원소
//
// Unordered Associative Contaiiner (순서없는 연관 컨테이너, Hash)
//	Unordered_map
//	Unordered_set

// 아이돌그룹의 이름과 멤버 수 
// map에 입력하고 출력해 보자

int main()
{
	map<string, int> idols;

	idols.insert(pair<string, int>("핑크레이디", 5)); // 2개를 하나처럼 페어 
	idols.insert(make_pair("있지", 5)); // 위에꺼 쉽게 쓰기
	idols.insert(make_pair("아이즈원", 12));
	idols.insert(make_pair("워너원", 11));
	idols.insert(make_pair("모모랜드", 9));
	idols.insert(make_pair("블랙핑크", 4));
	idols.insert(make_pair("트와이스", 9));
	idols.insert(make_pair("세븐틴", 13));
	idols.insert(make_pair("방탄소년단", 7));

	for (auto i = idols.begin(); i != idols.end(); ++i)
	{
		cout << (*i).first << ", " << i->second << endl;
	}

	// 맵은 원소를 빨리 찾기 ( O(log n) ) 위한 컨테이너이다
	// 사용자가 원하는 그룹의 인원수를 출력하는 프로그램을 작성하라

	string grop;

	while(grop != "종료")
	{
		cout << "찾을 그룹을 입력하세요 : ";
		cin >> grop;

		auto p = idols.find(grop); // 못찾으면 마지막 위치가 리턴된다
		if (p != idols.end())
			cout << p->first << ",맴버 수는 " << p->second << "명 입니다" << endl;
		else
			cout << "없는 정보입니다" << endl;
	}

	save("소스.cpp");
}

============================
 Fri Apr 19 12:00:37 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
using namespace std;

// Associative Container (연관 컨테이너)
//	map - dirctionay <key, value> 쌍이 원소
//	set - <key>가 원소
//
// Unordered Associative Contaiiner (순서없는 연관 컨테이너, Hash)
//	Unordered_map
//	Unordered_set

// 아이돌그룹의 이름과 멤버 수 
// map에 입력하고 출력해 보자

namespace std
{
	ostream& operator<<(ostream& os, const pair<string, int> p)
	{
		os << p.first << ", " << p.second << endl;
		return os;
	}
}

int main()
{
	map<string, int> idols;

	idols.insert(pair<string, int>("핑크레이디", 5)); // 2개를 하나처럼 페어 
	idols.insert(make_pair("있지", 5)); // 위에꺼 쉽게 쓰기
	idols.insert(make_pair("아이즈원", 12));
	idols.insert(make_pair("워너원", 11));
	idols.insert(make_pair("모모랜드", 9));
	idols.insert(make_pair("블랙핑크", 4));
	idols.insert(make_pair("트와이스", 9));
	idols.insert(make_pair("세븐틴", 13));
	idols.insert(make_pair("방탄소년단", 7));

	for (auto i = idols.begin(); i != idols.end(); ++i)
	{
		cout << (*i).first << ", " << i->second << endl;
	}

	// 맵은 원소를 빨리 찾기 ( O(log n) ) 위한 컨테이너이다
	// 사용자가 원하는 그룹의 인원수를 출력하는 프로그램을 작성하라

	for (const pair<string, int>&d : idols)
		cout << d.first << ", " << d.second << endl;

	// copy로 맵을 출력하자

	copy(idols.begin(), idols.end(), ostream_iterator<const pair<string, int>&>(cout));

	save("소스.cpp");
}

============================
 Fri Apr 19 12:06:56 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
using namespace std;

// Associative Container (연관 컨테이너)
//	map - dirctionay <key, value> 쌍이 원소
//	set - <key>가 원소
//
// Unordered Associative Contaiiner (순서없는 연관 컨테이너, Hash)
//	Unordered_map
//	Unordered_set

// 아이돌그룹의 이름과 멤버 수 
// map에 입력하고 출력해 보자

int main()
{
	map<string, int> idols;

	idols.insert(pair<string, int>("핑크레이디", 5)); // 2개를 하나처럼 페어 
	idols.insert(make_pair("있지", 5)); // 위에꺼 쉽게 쓰기
	idols.insert(make_pair("아이즈원", 12));
	idols.insert(make_pair("워너원", 11));
	idols.insert(make_pair("모모랜드", 9));
	idols.insert(make_pair("블랙핑크", 4));
	idols.insert(make_pair("트와이스", 9));
	idols.insert(make_pair("세븐틴", 13));
	idols.insert(make_pair("방탄소년단", 7));

	// 벨류 = idols[키];
	cout << idols["방탄소년단"] << endl; // associative array 처럼 사용 가능
	idols["방탄소녀단"] = 10; // 새로생성
	idols["방탄소년단"] = 10; // 원소변경

	save("소스.cpp");
}

============================
 Tue Apr 23 14:10:42 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <fstream>
using namespace std;

// Allice in wornderland 를 다운로드 해 주세요.
// 각 단어의 사용 횟수를 알고 싶다.
// 특정 단어를 입력하면 몇 번 사용되었는가 출력한다.
// 단어가 없으면 없다고 출력하자.

int main()
{
	string fname("앨리스.txt");

	ifstream in(fname);

	istream_iterator<string> beg{ in };
	istream_iterator<string> end{};

	map<string, int> words;

	string str;
	int cnt{};

	while (beg != end)
	{
		str = *beg++;
		cout << str << " ";
		cnt++;
		words[str]++; // 맵에 str 추가
	}

	// 맵을 출력
	for (const pair<string, int>& d : words)
	{
		cout << "[" << d.first << " ---> " << d.second << endl;
	}

	// 맵을 가장 많이 사용된 순서대로 출력
	multimap<int, string> isMap; // multimap과 map의 차이는 키값의 중복허용 차이이다

	for (const auto& d : words)
		isMap.insert(make_pair(d.second, d.first));

	cout << endl << "/////////////////////////////////////" << endl;

	for(const pair<int, string>& d: isMap)
		cout << "[" << d.second << " ---> " << d.first << endl;


	cout << endl << endl;
	cout << "단어의 수 : " << cnt << endl;
	cout << "중복 제외 단어의 수 : " << words.size() << endl;

	save("소스.cpp");
}




















============================
 Fri May  3 10:42:13 2019
============================

#include <iostream>
#include <set>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

int main()
{
	set<int> s{ 2,4,6,8,10,1,3,5,7,9 };

	// s의 원소를 화면에 출력해 보자
	for (int d : s)
		cout << d << endl;

	save("소스.cpp");
}

============================
 Fri May  3 10:44:21 2019
============================

#include <iostream>
#include <set>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

int main()
{
	set<int> s{ 2,4,6,8,10,1,3,5,7,9 };

	// s의 원소에 반복자를 사용하여 접근하자
	// 값을 화면에 출력해 보자
	for (auto i = s.begin(); i != s.end(); ++i)
		cout << *i << endl;

	save("소스.cpp");
}

============================
 Fri May  3 11:04:38 2019
============================

#include <iostream>
#include <set>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

struct X
{
	bool operator()(int a, int b)
	{
		return a < b;
	}
};

int main()
{
	// s를 오름차순으로 정렬하라
	// 정렬 형식은 X로 하여 만들어라

	set<int, X> s{ 2,4,6,8,10,1,3,5,7,9 };

	for (auto& d : s)
		cout << d << endl;

	save("소스.cpp");
}

============================
 Fri May  3 11:10:00 2019
============================

#include <iostream>
#include <set>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

template <> // 특수화
struct less<int>
{
	bool operator()(int a, int b)
	{
		return a > b;
	}
};

int main()
{
	// main()을 변경하지 않고 s를 내림차순으로 정렬하라

	set<int> s{ 2,4,6,8,10,1,3,5,7,9 };

	for (auto& d : s)
		cout << d << endl;

	save("소스.cpp");
}

============================
 Fri May  3 11:32:37 2019
============================

#include <iostream>
#include <set>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

template <>
struct less<MemoryMonster>
{
	bool operator()(const MemoryMonster& a, const MemoryMonster& b)
	{
		return a.getNum() < b.getNum();
	}
};

int main()
{
	// s가 글자의 길이 기준으로 오름차순 정렬하도록 하라
	set<MemoryMonster> s{ 2,4,6,8,10,1,3,5,7,9 };

	for (auto& d : s)
		cout << d << endl;

	save("소스.cpp");
}

============================
 Fri May  3 11:49:26 2019
============================

#include <iostream>
#include <set>
#include <string>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

class Dog
{
	string name;

public :
	Dog(string name) : name{ name } {}

	operator string() const
	{
		return name;
	}

	bool operator<(const Dog& rhs) const
	{
		return name < rhs.name;
	}
};

int main()
{
	set<Dog> s{ string("댕댕이"), string("나비"), string("야옹이"), string("바둑이"), string("나비") };

	for (const Dog& d : s)
		cout << (string)(d) << endl;

	save("소스.cpp");
}

============================
 Fri May  3 11:52:27 2019
============================

#include <iostream>
#include <set>
#include <string>
#include "MemoryMonster.h"
#include "save.h"

// set에 정수를 몇 개 넣어 보고 관찰해 보자

class Dog
{
	string name;

public :
	Dog(string name) : name{ name } {}

	operator string() const
	{
		return name;
	}

	bool operator<(const Dog& rhs) const
	{
		return name < rhs.name;
	}

	friend ostream& operator<<(ostream& os, const Dog& d)
	{
		os << d.name;
		return os;
	}
};

int main()
{
	multiset<Dog> s{ string("댕댕이"), string("나비"), string("야옹이"), string("바둑이"), string("나비") };

	for (const Dog& d : s)
		cout << d << endl;

	save("소스.cpp");
}

============================
 Fri May  3 12:00:26 2019
============================

#include <iostream>
#include <set>
#include <string>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	// 앨리스.txt의 모든 단어를 multiset에 읽어라.

	ifstream in("앨리스.txt");

	multiset<string> words{ istream_iterator<string> { in } ,istream_iterator<string> {} };
	cout << words.size();

	auto p = words.begin();
	advance(p, 10000);

	for (int i = 0; i < 100; ++i)
		cout << *p++ << endl;

	save("소스.cpp");
}

============================
 Fri May  3 12:12:48 2019
============================

#include <iostream>
#include <set>
#include <string>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	// 앨리스.txt의 모든 단어를 multiset에 읽어라.

	ifstream in("앨리스.txt");

	multiset<string> words{ istream_iterator<string> { in } ,istream_iterator<string> {} };
	cout << words.size();

	// 단어의 갯수를 출력하라
	for (auto i = words.begin(); i != words.end(); i = words.upper_bound(*i))
		cout << "[" << *i << "] ---> " << words.count(*i) << endl;

	// 갯수가 가장 많은 단어부터 20개를 출력해 보라

	save("소스.cpp");
}

============================
 Fri May  3 12:15:52 2019
============================

#include <iostream>
#include <set>
#include <string>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	// 앨리스.txt의 모든 단어를 multiset에 읽어라.

	ifstream in("앨리스.txt");

	multiset<string> words{ istream_iterator<string> { in } ,istream_iterator<string> {} };
	cout << words.size();

	// 단어의 갯수를 출력하라
	vector< pair<string, int>> v;

	for (auto i = words.begin(); i != words.end(); i = words.upper_bound(*i))
		v.emplace_back(*i, words.count(*i));

	sort(v.begin(), v.end()); // 정렬

	// 갯수가 가장 많은 단어부터 20개를 출력해 보라

	save("소스.cpp");
}

============================
 Fri May  3 12:21:59 2019
============================

#include <iostream>
#include <set>
#include <string>
#include <map>
#include <vector>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	// 앨리스.txt의 모든 단어를 multiset에 읽어라.

	ifstream in("앨리스.txt");

	multiset<string> words{ istream_iterator<string> { in } ,istream_iterator<string> {} };
	cout << words.size();

	multimap<int, string, greater<int>> mm;

	for (auto i = words.begin(); i != words.end(); i = words.upper_bound(*i))
		mm.emplace(words.count(*i), *i);


	// 갯수가 가장 많은 단어부터 20개를 출력해 보라
	auto p = mm.begin();;
	for (int i = 0; i < 20; ++i, ++p)
		cout << p->second << " ---> " << p->first << endl;

	save("소스.cpp");
}

============================
 Tue May  7 13:40:01 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	unordered_map<string, string> pBook;

	pBook.insert(make_pair("경찰서", "112"));
	pBook.insert(pair<string, string> ("소방서", "119"));
	pBook.emplace("번호안내", "114");

	for (auto a : pBook)
		cout << a.first << " " << a.second << endl;

	save("소스.cpp");
}

============================
 Tue May  7 13:42:46 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	unordered_map<string, string> pBook; // <- map이랑 다른거 없음
	pBook.insert(make_pair("경찰서", "112"));
	pBook.insert(pair<string, string> ("소방서", "119"));
	pBook.emplace("번호안내", "114");

	for (const pair<string, string>&a : pBook)
		cout << a.first << " " << a.second << endl;

	save("소스.cpp");
}

============================
 Tue May  7 14:09:08 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"

int main()
{
	unordered_map<string, string> pBook;

	pBook.insert(make_pair("경찰서", "112"));
	pBook.insert(pair<string, string> ("소방서", "119"));
	pBook.emplace("번호안내", "114");
	pBook["국정원"] = "111";

	for (int i = 0; i < pBook.size(); ++i)
	{
		cout << "[" << i << "] --- ";
		if (pBook.bucket_size(i))
		{
			for (auto b = pBook.begin(i); b != pBook.end(i); ++b)
				cout << b->second << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
}

============================
 Tue May  7 14:52:17 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"

class X {
public:
	size_t operator()(const MemoryMonster& a) const
	{
		return hash<string>()(a.getData());
	}
};

int main()
{
	unordered_multimap<MemoryMonster, int, X> pBook;

	pBook.emplace(10, 10);

	for (int i = 0; i < pBook.bucket_count(); ++i)
	{
		cout << "[" << i << "] --- ";
		if (pBook.bucket_size(i))
		{
			for (auto b = pBook.begin(i); b != pBook.end(i); ++b)
				cout << b->second << " ";
		}
		cout << endl;
	}

	save("소스.cpp");
}

============================
 Tue May  7 15:12:28 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"

class Dog {
	string name;
public:
	string getName() const { return name; }
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	unordered_multimap<Dog, int> dogs;

	dogs.emplace("코코", 3);
	dogs.emplace("초코", 1);
	dogs.emplace("별이", 5);

	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		cout << "[" << i << "] --- ";
		if (dogs.bucket_size(i))
		{
			for (auto b = dogs.begin(i); b != dogs.end(i); ++b)
				cout << b->second << " ";
		}
		cout << endl;
	}

	//save("소스.cpp");
}

============================
 Tue May  7 15:18:23 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"

class Dog {
	string name;
public:
	Dog(string name) : name{ name } {}

	string getName() const { return name; }
	
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	unordered_map<Dog, int> dogs;

	dogs.emplace("코코", 3);
	dogs.emplace("초코", 1);
	dogs.emplace("별이", 5);

	for (int i = 0; i < dogs.bucket_count(); ++i)
	{
		cout << "[" << i << "] --- ";
		if (dogs.bucket_size(i))
		{
			for (auto b = dogs.begin(i); b != dogs.end(i); ++b)
				cout << b->second << " ";
		}
		cout << endl;
	}

	cout << dogs[string("코코")] << endl;

	save("소스.cpp");
}

============================
 Fri May 10 10:41:38 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"
#include <vector>
#include <initializer_list>

class Dog {
	string name;
public:
	Dog(string name) : name{ name } {}

	string getName() const { return name; }
	
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	initializer_list<string> names{ "코코","별이","콩이" };
	vector<Dog> v{names.begin(), names.end()};

	save("소스.cpp");
}

============================
 Fri May 10 10:46:39 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"
#include <vector>
#include <initializer_list>

class Dog {
	string name;
public:
	Dog(string name) : name{ name } {}

	string getName() const { return name; }
	
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	vector<Dog> v{ string("코코"),string("별이"),string("콩이") };

	save("소스.cpp");
}

============================
 Fri May 10 10:59:23 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"
#include <vector>
#include <initializer_list>

class Dog {
	string name;
public:
	Dog(string name) : name{ name } {}

	string getName() const { return name; }
	
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	vector<Dog> v{ string("코코"),string("별이"),string("콩이") };

	// "해피"라는 이름의 개가 vector v 에 있는 지 찾아보라

	auto p = find(v.begin(), v.end(), Dog("해피"));
	if (p != v.end())
		cout << "찾음" << endl;
	else
		cout << "못찾음" << endl;

	save("소스.cpp");
}

============================
 Fri May 10 11:11:59 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"
#include <vector>
#include <initializer_list>
#include <algorithm>

class Dog {
	string name;
public:
	Dog(string name) : name{ name } {}

	string getName() const { return name; }
	
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

struct DogHash {
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	// 이번엔 unordered_map 일때 찾기

	unordered_map<Dog, int, DogHash> m;
	m.emplace("코코", 1);
	m.emplace("별이", 2);
	m.emplace("콩이", 3);

	// "해피"라는 이름의 개가 있는 지 찾아보라

	auto p = m.find(Dog("해피"));
	if (p != m.end())
		cout << "찾음" << endl;
	else
		cout << "못찾음" << endl;

	save("소스.cpp");
}

============================
 Fri May 10 11:15:01 2019
============================

#include <iostream>
#include <string>
#include <unordered_map>
#include "MemoryMonster.h"
#include "save.h"
#include <vector>
#include <initializer_list>
#include <algorithm>

class Dog {
	string name;
public:
	Dog(string name) : name{ name } {}

	string getName() const { return name; }
	
	bool operator == (const Dog& other) const
	{
		return name == other.name;
	}
};

template <>
struct hash<Dog>
{
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

struct DogHash {
	int operator()(const Dog& d) const
	{
		return hash<string>()(d.getName());
	}
};

int main()
{
	// 이번엔 unordered_map 일때 찾기

	unordered_map<Dog, int, DogHash> m;
	m.emplace("코코", 1);
	m.emplace("별이", 2);
	m.emplace("콩이", 3);

	// "해피"라는 이름의 개가 있는 지 찾아보라

	auto p = m[Dog("해피")];
	cout << p << endl;

	save("소스.cpp");
}

============================
 Fri May 10 11:36:17 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;
#include <map>
#include <algorithm>

// 정수 1000만개를 unorderde_map과 map에 저장한다
// 임의의 정수 100만개가 컨테이너에 있는 지 찾아본다
// 각각 걸리는 시간을 측정한다

int main()
{
	// 정수 1000만개를 map에 넣는다.
	map<int, int> m;

	default_random_engine dre;
	uniform_int_distribution<> uid;

	for (int i = 0; i < 1000'0000; ++i)
		m.emplace(uid(dre), i);

	cout << "맵 생성" << endl;

	save("소스.cpp");
}

============================
 Fri May 10 12:02:42 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;
#include <map>
#include <algorithm>
#include <unordered_map>
#include <chrono>
#include <random>
using namespace std::chrono;

// 정수 1000만개를 unorderde_map과 map에 저장한다
// 임의의 정수 100만개가 컨테이너에 있는 지 찾아본다
// 각각 걸리는 시간을 측정한다

int main()
{
	// 정수 1000만개를 map에 넣는다.
	map<int, int> m;

	default_random_engine dre;
	uniform_int_distribution<> uid;

	int i{};
	while( m.size() != 1000'0000)
		m.emplace(uid(dre), ++i);

	cout << "map 생성" << m.size() << endl;

	// map의 원소를 그대로 unordered_map에 넣는다

	unordered_map<int, int> um{ m.begin(), m.end() };
	cout << "unordered map 생성" << um.size() << endl;

	{
		cout << "임의의 정수 100만개를 map에서 찾아보자" << endl;
		cout << "찾기 시작" << endl;

		auto b = steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
			m.find(uid(dre));

		auto d = duration_cast<milliseconds>(steady_clock::now() - b).count();

		cout << "걸린 시간은 - " << d << endl;
	}

	{
		cout << "임의의 정수 100만개를 unordered map에서 찾아보자" << endl;
		cout << "찾기 시작" << endl;

		auto b = steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
			um.find(uid(dre));

		auto d = duration_cast<milliseconds>(steady_clock::now() - b).count();

		cout << "걸린 시간은 - " << d << endl;
	}


	save("소스.cpp");
}

============================
 Fri May 10 12:06:36 2019
============================

#include <iostream>
#include "MemoryMonster.h"
#include "save.h"
using namespace std;
#include <map>
#include <algorithm>
#include <unordered_map>
#include <chrono>
#include <random>
#include <vector>
using namespace std::chrono;

// 정수 1000만개를 unorderde_map과 map에 저장한다
// 임의의 정수 100만개가 컨테이너에 있는 지 찾아본다
// 각각 걸리는 시간을 측정한다

int main()
{
	// 정수 1000만개를 map에 넣는다.
	map<int, int> m;

	default_random_engine dre;
	uniform_int_distribution<> uid;

	int i{};
	while( m.size() != 1000'0000)
		m.emplace(uid(dre), ++i);

	cout << "map 생성" << m.size() << endl;

	// map의 원소를 그대로 unordered_map에 넣는다

	unordered_map<int, int> um{ m.begin(), m.end() };
	cout << "unordered map 생성" << um.size() << endl;

	// 찾을 값 100만개를 vector에 저장한다

	cout << "백터에 인덱스 100만개를 생성하였다" << endl;
	vector<int> v;
	v.reserve(100'0000);
	for (int i = 0; i < 100'0000; ++i)
	{
		v.push_back(uid(dre));
	}

	{
		cout << "임의의 정수 100만개를 map에서 찾아보자" << endl;
		cout << "찾기 시작" << endl;

		auto b = steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
			m.find(v[i]);

		auto d = duration_cast<milliseconds>(steady_clock::now() - b).count();

		cout << "걸린 시간은 - " << d << endl;
	}

	{
		cout << "임의의 정수 100만개를 unordered map에서 찾아보자" << endl;
		cout << "찾기 시작" << endl;

		auto b = steady_clock::now();

		for (int i = 0; i < 100'0000; ++i)
			um.find(v[i]);

		auto d = duration_cast<milliseconds>(steady_clock::now() - b).count();

		cout << "걸린 시간은 - " << d << endl;
	}


	save("소스.cpp");
}